"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCreateTransferRemarks = exports.validateCreateBeneficiary = exports.truncateCreateBeneficiary = void 0;
const Validators_1 = require("../types/models/Validators");
const Beneficiary_1 = require("../types/models/Beneficiary");
const generateRandomString = (length) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
};
const truncateString = (stringToTrunacate, limit) => {
    if (stringToTrunacate.length <= limit) {
        return stringToTrunacate;
    }
    const randomSuffix = generateRandomString(5);
    let truncatedString = stringToTrunacate.substring(0, limit - 5) + randomSuffix;
    return truncatedString;
};
exports.truncateCreateBeneficiary = (validators, beneficiary) => {
    const { type } = beneficiary;
    if (!type) {
        throw new Validators_1.ValidatorError({
            type: 'PARAMETER_MISSING',
            message: 'type is missing',
        });
    }
    else if (type !== Beneficiary_1.BeneficiaryType.LOCAL && type !== Beneficiary_1.BeneficiaryType.SAME) {
        throw new Validators_1.ValidatorError({
            type: 'PARAMETER_ERROR',
            message: 'type has to be local or same',
        });
    }
    const { createBeneficiary } = validators;
    const validatorProps = createBeneficiary[type];
    Object.keys(validatorProps).map((key) => {
        if (key === 'address') {
            Object.keys(validatorProps[key]).map((addressKey) => {
                if (addressKey !== 'length') {
                    if ((validatorProps[key][addressKey].required && beneficiary[key]) ||
                        (validatorProps[key][addressKey].optional && beneficiary[key]) ||
                        addressKey in beneficiary[key]) {
                        if (!beneficiary[key][addressKey]) {
                            throw new Validators_1.ValidatorError({
                                type: 'PARAMETER_MISSING',
                                message: `${addressKey} is missing`,
                            });
                        }
                        else if (validatorProps[key][addressKey].length < beneficiary[key][addressKey].length) {
                            beneficiary[key][addressKey] = truncateString(beneficiary[key][addressKey], validatorProps[key][addressKey].length);
                            if (beneficiary[key][addressKey].match(validatorProps[key][addressKey].allowedCharacters)[0] !== beneficiary[key][addressKey]) {
                                beneficiary[key][addressKey] = beneficiary[key][addressKey].replace(/[^a-zA-Z ]/g, '');
                            }
                        }
                    }
                }
            });
        }
        else if ((validatorProps[key].required && beneficiary[key]) ||
            (validatorProps[key].optional && beneficiary[key]) ||
            key in beneficiary) {
            if (!beneficiary[key]) {
                throw new Validators_1.ValidatorError({
                    type: 'PARAMETER_MISSING',
                    message: `${key} is missing`,
                });
            }
            else if (validatorProps[key].length < beneficiary[key].length) {
                beneficiary[key] = truncateString(beneficiary[key], validatorProps[key].length);
                if (beneficiary[key].match(validatorProps[key].allowedCharacters)[0] !== beneficiary[key]) {
                    beneficiary[key] = beneficiary[key].replace(/[^a-zA-Z ]/g, '');
                }
            }
        }
    });
    return beneficiary;
};
exports.validateCreateBeneficiary = (validators, beneficiary) => {
    const { type } = beneficiary;
    if (!type) {
        throw new Validators_1.ValidatorError({
            type: 'PARAMETER_MISSING',
            message: 'type is missing',
        });
    }
    else if (type !== Beneficiary_1.BeneficiaryType.LOCAL && type !== Beneficiary_1.BeneficiaryType.SAME) {
        throw new Validators_1.ValidatorError({
            type: 'PARAMETER_ERROR',
            message: 'type has to be local or same',
        });
    }
    const { createBeneficiary } = validators;
    const validatorProps = createBeneficiary[type];
    Object.keys(validatorProps).map((key) => {
        if (key === 'address') {
            Object.keys(validatorProps[key]).map((addressKey) => {
                if (addressKey !== 'length') {
                    Object.keys(validatorProps[key][addressKey]).map((addressLinesKey) => {
                        if ((validatorProps[key][addressKey].required && beneficiary[key]) ||
                            (validatorProps[key][addressKey].optional && beneficiary[key])) {
                            if (!beneficiary[key][addressKey]) {
                                throw new Validators_1.ValidatorError({
                                    type: 'PARAMETER_MISSING',
                                    message: `${addressLinesKey} is missing`,
                                });
                            }
                            else if (validatorProps[key][addressKey].length < beneficiary[key][addressKey].length) {
                                throw new Validators_1.ValidatorError({
                                    type: 'PARAMETER_ERROR',
                                    message: `${addressLinesKey} is too long. Maximum length: ${validatorProps[key][addressKey].length}. But got length: ${beneficiary[key][addressKey].length}`,
                                });
                            }
                            else if (validatorProps[key][addressKey].allowedCharacters !== '') {
                                if (beneficiary[key][addressKey].match(validatorProps[key][addressKey].allowedCharacters)[0] !== beneficiary[key][addressKey]) {
                                    throw new Validators_1.ValidatorError({
                                        type: 'PARAMETER_ERROR',
                                        message: `${addressLinesKey} should not contain special characters`,
                                    });
                                }
                            }
                        }
                    });
                }
            });
        }
        else if ((validatorProps[key].required && beneficiary[key]) ||
            (validatorProps[key].optional && beneficiary[key])) {
            if (!beneficiary[key]) {
                throw new Validators_1.ValidatorError({
                    type: 'PARAMETER_MISSING',
                    message: `${key} is missing`,
                });
            }
            else if (validatorProps[key].length < beneficiary[key].length) {
                throw new Validators_1.ValidatorError({
                    type: 'PARAMETER_ERROR',
                    message: `${key} is too long. Maximum length: ${validatorProps[key].length}. But got length: ${beneficiary[key].length}`,
                });
            }
            else if (validatorProps[key].allowedCharacters !== '') {
                if (beneficiary[key].match(validatorProps[key].allowedCharacters)[0] !== beneficiary[key]) {
                    throw new Validators_1.ValidatorError({
                        type: 'PARAMETER_ERROR',
                        message: `${key} should not contain special characters`,
                    });
                }
            }
        }
    });
};
exports.validateCreateTransferRemarks = () => { };
